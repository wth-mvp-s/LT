
##   8Â°3-4


#### 15_Qp32 [0%]::You develop a solution that uses Azure Virtual Machines (VMs).
`The VMs contain code that must access resources in an Azure resource group. You grant the VM access to the resource group in Resource Manager.
`You need to obtain an access token that uses the VM's system-assigned managed identity.
`Which two actions should you perform?


- [x] From the code on the VM, call Azure Resource Manager using an access token.
- [ ] Use PowerShell on a remote machine to make a request to the local managed identity for Azure resources endpoint.
- [x] Use PowerShell on the VM to make a request to the local managed identity for Azure resources endpoint.
- [ ] From the code on the VM, call Azure Resource Manager using a SAS token.
- [ ] From the code on the VM, generate a user delegation SAS token.


#### 16_Qp33 [0%]::You are developing a road tollway tracking application that sends tracking events by using Azure Event Hubs using premium tier.
`Each road must have a throttling policy uniquely assigned.
`You need to configure the event hub to allow for per-road throttling.
`What should you do?


- [ ] Use a unique consumer group for each road.
- [ ] Ensure each road stores events in a different partition.
- [ ] Ensure each road has a unique connection string.
- [x] Use a unique application group for each road.


#### 17_Qp34 [0%]::You develop and deploy an ASP.NET Core application that connects to an Azure Database for MySQL instance.
`Connections to the database appear to drop intermittently and the application code does not handle the connection failure.
`You need to handle the transient connection errors in code by implementing retries.
`What are three possible ways to achieve this goal?


- [ ] Close the database connection and immediately report an error.
- [ ] Disable connection pooling and configure a second Azure Database for MySQL instance.
- [x] Wait five seconds before repeating the connection attempt to the database.
- [x] Set a maximum number of connection attempts to 10 and report an error on subsequent connections.
- [x] Increase connection repeat attempts exponentially up to 120 seconds.

#### 18_Qp35 [0%]::You are building a B2B web application that uses Azure B2B collaboration for authentication. Paying customers authenticate to Azure B2B using federation.
`The application allows users to sign up for trial accounts using any email address.
`When a user converts to a paying customer, the data associated with the trial should be kept, but the user must authenticate using federation.
`You need to update the user in Azure Active Directory (Azure AD) when they convert to a paying customer.
`Which Graph API parameter is used to change authentication from one-time passcodes to federation?


- [x] resetRedemption
- [ ] Status
- [ ] userFlowType
- [ ] invitedUser


#### 19_Q_QC.1 [0%]::
`Issues -
`
`Shipping website and REST APIs -The following error message displays while you are testing the website: 
`Failed to load http://test-shippingapi.wideworldimporters.com/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://test.wideworldimporters.com/' is therefore not allowed access.
`
`Question
`You need to configure Azure CDN for the Shipping web site.
`Which configuration options should you use?


- [ ] 
`Tier : Standard
`Profile Akamai
`Optimization : general web delivery

- [ ] 
`Tier : Premium
`Profile : Microsoft
`Optimization : large file download

- [ ] 
`Tier : Standard
`Profile : Akamai
`Optimization : large file download

- [x] 
`Tier : Standard
`Profile : Akamai
`Optimization : dynamic site acceleraiton

- [ ] 
`Tier : Standard
`Profile : Akamai
`Optimization : general web delivery

- [ ] 
`Tier : Standard
`Profile : Microsoft
`Optimization : dynamic site acceleraiton

- [ ] 
`Tier : Standard
`Profile : Akamai
`Optimization : video-on-demand media streaming







#### 20 []::
`Issues -
`
`Windows Server 2016 VM -
`The VM shows high network latency, jitter, and high CPU utilization. The VM is critical and has not been backed up in the past. The VM must enable a quick restore from a 7-day snapshot to include in-place restore of disks in case of failure.
`
`Shipping website and REST APIs -
`The following error message displays while you are testing the website:
`Failed to load http://test-shippingapi.wideworldimporters.com/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://test.wideworldimporters.com/' is therefore not allowed access.
`
`Question
`
`You need to correct the VM issues.
`Which tools should you use? 


- [ ] Backup and Restore Azure Site Recovery
- [x] Backup and Restore Azure Backup
- [ ] Backup and Restore Azure Data Box
- [ ] Backup and Restore Azure Migrate
- [ ] Performance Azure Network Watcher
- [ ] Performance Azure Traffic Manager
- [ ] Performance ExpressRoute
- [x] Performance Accelerated Networking

#### 21 []::
`Question
`
`You need to add code at line PC32 in Processing.cs to implement the GetCredentials method in the Processing class.
`How should you complete the code?

- [x] 
`var tp = new AzureServiceTokenProvider()
`var t = new TokenCredential(await tp.GetAccessTokenAsync(". . ."))
`return new StorageCredentials(t); 

- [ ] 
`var tp = new StringTokenProvider("storage", "msi")
`var t = new TokenCredential(await tp.GetAccessTokenAsync(". . ."))
`return new StorageCredentials(t); 

- [ ] 
`var tp = new MSITokenProvider(". . . ", null)
`var t = new TokenCredential(await tp.GetAccessTokenAsync(". . ."))
`return new StorageCredentials(t); 

- [ ] 
`var tp = new MSITokenProvider(". . . ", null)
`var t = new TokenCredential(await tp.GetAuthenticationHeaderAsync(CancellationToken.None))
`return new StorageCredentials(t); 

- [ ] 
`var tp = new AzureServiceTokenProvider()
`var t = new TokenCredential(await tp.GetAuthenticationHeaderAsync(CancellationToken.None))
`return new StorageCredentials(t); 


#### 22 [voters]::
`Question
`
`You need to ensure disaster recovery requirements are met.
`What code should you add at line PC16?

- [x] 
`var copyOptions = new CopyOptions {}; 
`var context = new SingleTransferContext = (source, destination) => Task.FromResult(true);
`context.ShouldOverwriteCallbackAsync = (source, destination) => Task.FromResult(true);
`await TransferManager.CopyAsync(blob), isServiceCopy: false
`context: context, options: copyOptions); 


- [ ] 
`var copyOptions = new CopyOptions {}; 
`var context = new DirectoryTransferContext = (source, destination) => Task.FromResult(true);
`context.ShouldTransferCallbackAsync = (source, destination) => Task.FromResult(true);
`await TransferManager.CopyAsync(blob), isServiceCopy: false
`context: context, options: copyOptions); 

- [ ] 
`var copyOptions = new CopyOptions {}; 
`var context = new SingleTransferContext = (source, destination) => Task.FromResult(true);
`context.ShouldTransferCallbackAsync = (source, destination) => Task.FromResult(true);
`await TransferManager.CopyAsync(blob), isServiceCopy: false
`context: context, options: copyOptions); 


- [ ] 
`var copyOptions = new CopyOptions {}; 
`var context = new DirectoryTransferContext = (source, destination) => Task.FromResult(true);
`context.ShouldOverwriteCallbackAsync = (source, destination) => Task.FromResult(true);
`await TransferManager.CopyAsync(blob), isServiceCopy: false
`context: context, options: copyOptions); 


- [ ] 
`var copyOptions = new CopyOptions {}; 
`var context = new DirectoryTransferContext = (source, destination) => Task.FromResult(true);
`context.ShouldTransferCallbackAsync = (source, destination) => Task.FromResult(true);
`await TransferManager.CopyAsync(blob), isServiceCopy: true
`context: context, options: copyOptions); 

